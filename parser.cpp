#include "scanner.h"
#include "parser.h"

using namespace std;

/*
This program is a recursive-descent parser for a subset of the SCL grammar. The subset is designed to be able to handle SCL code that can create 
forward declarations of functions; multiple functions; basic arithmetic; basic logic expressions; three kinds of control statements: if 
statements, for loops, and while loops; input and output statements, and return types for functions. The language defines 4 basic data types: 
integers, floats, booleans (called bool), and strings. Since this is a recursive descent parser, each non-terminal symbol in the grammar has its
own function. Those functions are code representations of the grammar rules. For any non-terminal that apears on the Right Hand Side(RHS) of a 
grammar rule, the code calls that non-terminal's function. For optional or multiple non-terminals, if statements and loops are used, respectively.
Each call to the function lex() i a call to the scanner from deliverable 1. It consumes the current token and loads the next token to be parsed. 
For the full list of grammar rules, see the Grammar.txt file included with the project submision.
*/

int main(int argc, char ** argv) { //This is the main driver program for the parser. It populates the reservedWords and symbols tables for the scanner, opens the input 
             //file, lex()'s the first token, and then calls program() to start parsing the file.
    try {
    populateReseservedWordsAndSymbols();
    if(argc > 1) {
        inputFile.open(argv[1]);
    }else {
        inputFile.open("test4.scl");
    }
    if(inputFile.fail()) {
        cout << "unable to open file. check file name and try again" << endl;
        exit(1);
    }
    getChar();
    lex();
    AST_NODE_PROGRAM * codeFile = program();
    map<string, SCL_TYPE> varriableTable;
    map<string, AST_NODE_FUNCTION *> functionTable;
    Environment * env = new Environment(varriableTable, functionTable);
    SCL_TYPE output = codeFile->evaluate(env);
    
    // determineOutput(output);
    }catch (const SCLException &e){
        cout << e.file << ":" << e.line << " " << e.message << endl;
    }catch(const exception & e) {
        cout << "Unknown error" << endl;
    }
}

/*  program
    Parses strings in the language generated by the rule:
    <program> --> [<forward_declare>] [<implementation>]
*/
AST_NODE_PROGRAM * program() { 
    // cout << "Entered <program>" << endl;
    AST_NODE_FORWARD_DECLARE * declarations = NULL;
    AST_NODE_IMPLEMENTATIONS * implementations = NULL;
    if((token != FORWARD) && (token != IMPLEMENTATIONS)) { // If the token is not equal to forward and not equal to implementations, an 
                                                           // error will print
        error("Expected forward declarations or implementations.");
    }
    if(token == FORWARD) { // This checks if the token is equal to forward. If it is, it executes the forward_declare() function, meaning it 
                           // calls the grammar rule for handling forward declarations of functions
        declarations = forward_declare();
    }
    if(token == IMPLEMENTATIONS) { //This checks if the token is equal to implementations. If it is, it executes the implementation() function
        implementations = implementation();
    } 
    // cout << "Exited <program>" << endl;
    return new AST_NODE_PROGRAM(declarations, implementations);
    
}

/*  forward_declare: 
    Parses strings in the language generated by the rule:
    <forward_declare> --> forward declarations <function_proto>*
*/ 
AST_NODE_FORWARD_DECLARE * forward_declare() {
    // cout << "Entered <forward_declare>" << endl;
    AST_NODE_FUNCTION_PROTO * adder = NULL;
    vector<AST_NODE_FUNCTION_PROTO *> function_proto_list;
    if(token != FORWARD) { // Error checking. If the token is not forward, then print out an error.
        error("Expected word forward");
    }
    lex(); // This call for lex() consumes the current token and moves on to the next one. Since we have correctly parsed forward, we can now 
           // consume it and move on. In general, lex() gets called everytime we have correctly parsed a terminal symbol and wish to move on to
           // the next word.
    if(token != DECLARATIONS) { // More error checking. If the token is not forward, then print out an error.
        error("Expected word declarations");
    }
    lex(); // The word was correct. Consume it and move on to the next token.
    while(token == FUNCTION) { // We want to allow for any number of function prototypes. This while loop will call function_proto() as long as
                               // the token after handling the function prototypes still corresponds to another function prototype 
        adder = function_proto(); // Parse the function prototypes
        function_proto_list.push_back(adder);
    }
    // cout << "Exited <forward_declare>" << endl;
    return new AST_NODE_FORWARD_DECLARE (function_proto_list);
}

/*  implementation
    Parses strings in the language generated by the rule:
    <implementation> --> implementations <function>*
*/
AST_NODE_IMPLEMENTATIONS * implementation() { 
    // cout << "Entered <implementation>" << endl;
    AST_NODE_FUNCTION * adder = NULL;
    vector<AST_NODE_FUNCTION *> function_list;
    if(token != IMPLEMENTATIONS) { // Error checking to make sure the token is correct.
        error("Expected word implementations");
    }
    lex(); // Since the token was correct if this line was reached, consume that token and move on to the next portion of the grammar rule.
    while(token == FUNCTION) { // The same while loop as in function_proto(), for the same purpose. We want to allow for any number of functions,
                               // so loop until the token no longer corresponds to <function> non-terminals.
        adder = function(); // Parse the functions
        function_list.push_back(adder);
    }
    // cout << "Exited <implementation" << endl;
    return new AST_NODE_IMPLEMENTATIONS(function_list);
}


/*  function_proto
    Parses strings in the language generated by the rule:
    <function_proto> --> function <id> return <type>
*/
AST_NODE_FUNCTION_PROTO * function_proto() {
    // cout << "Entered <function_proto>" << endl;    
    if(token != FUNCTION) { // Error checking the token again.
        error("Expected word function");
    }
    lex(); // Consume the current token and load the next one. 
    AST_NODE_ID * ident = id(); // Parse the identifier
    if(token != RETURN) { //Error checking again
        error("Expected word return");
    }
    lex(); // Consume the current token and load the next one.
    AST_NODE_TYPE * return_type = type(); // Parse the type non-terminal

    // cout << "Exited <function_proto>" << endl;
    
    return new AST_NODE_FUNCTION_PROTO(ident, return_type);

   
}

/*
   function
    Parses strings in the language generated by the rule:
    <function> --> function <id> is [<parameter_list>] <varribale_list> begin <statement>* endfun <id>
*/
AST_NODE_FUNCTION * function() {
    // cout << "Entered <function>" << endl;
    if(token != FUNCTION) { // Error checking
        error("Expected word function");
    }
    lex(); // Consume and loadd token
    AST_NODE_ID * function_name = id(); // Parse the identifier non-terminal
    if(token != IS) { // Error checking to make sure the token is "is"
        error("Expected word is");
    }
    lex(); // Consume and load the token
    AST_NODE_PARAMETER_LIST * parameters = NULL; //function could have no parameters.
    if (token == PARAMETERS) {
        parameters = parameter_list(); //Or function could have parametes
    }
    AST_NODE_VARIBALE_LIST * variables = variable_list(); // Parse the variable list
    if(token != BEGIN) { // Error checking
        error("Expected word begin");
    }
    lex(); // Consume and load token
    AST_NODE_STATEMENT * adder = NULL;
    vector<AST_NODE_STATEMENT *> statement_list;
    while(isStatement()) { // This while loop allows for multiple <statement> non-terminals. The call to isStatement() returns true if the current
                           // token is one of the terminals that could begin any statement.
        adder = statement(); // Parse the statements
        statement_list.push_back(adder);
    }
    if(token != ENDFUN) { // More error checking
        error("Expected word endfun");    
    }
    lex(); // Consume and load
    id(); // Parse the identifier

    // cout << "Exited <function>" << endl;
    return new AST_NODE_FUNCTION(function_name, parameters, variables, statement_list);
}

/*  parameter_list
    Parses strings in the language generated by the rule:
    <parameter_list> --> parameters <definition>*
*/
AST_NODE_PARAMETER_LIST * parameter_list() {
    // cout << "Entered <parameter_list>" << endl;
    AST_NODE_DEFINITION * adder;
    vector<AST_NODE_DEFINITION *> definition_list;
    if(token != PARAMETERS) {
        error("Expected word parameters");
    }
    lex(); // Error checking and consuming and loadind the token
    while(token == DEFINE) { // Loop to allow for any number of definitions of variables
        adder = definition(); // Parse the definitions()
        definition_list.push_back(adder);
    }
    
    // cout << "Exited <parameter_list>" << endl;
    return new AST_NODE_PARAMETER_LIST(definition_list);
}

/*  variable_list
    Parses strings in the language generated by the rule:
    <variable_list> --> variables <definition>*
*/
AST_NODE_VARIBALE_LIST * variable_list() {
    // cout << "Entered <variable_list>" << endl;
    AST_NODE_DEFINITION * adder;
    vector<AST_NODE_DEFINITION *> definition_list;
    if(token != VARIABLES) {
        error("Expected word variables");
    }
    lex(); // Error checking and consuming and loadind the token
    while(token == DEFINE) { // Loop to allow for any number of definitions of variables
        adder = definition(); // Parse the definitions()
        definition_list.push_back(adder);
    }
    
    // cout << "Exited <variable_list>" << endl;
    return new AST_NODE_VARIBALE_LIST(definition_list);
}

/*  definition
    Parses strings in the language generated by the rule:
    <definition> --> define <id> of type <type>
*/
AST_NODE_DEFINITION * definition() {
    // cout << "Entered <definition>" << endl;
    if(token != DEFINE) {
        error("Expected word define");
    }
    lex(); // Error Check, consume, load
    AST_NODE_ID * identifier = id(); // Parse ientifier non-terminal
    if(token != OF) {
        error("Expected word of");
    }
    lex(); // Error Check, consume, load
    if(token != TYPE) {
        error("Expected word type");
    }
    lex(); // Error Check, consume, load
    AST_NODE_TYPE * variable_type = type(); // Parse the type non-terminal
    // cout << "Exited <definition>" << endl;
    return new AST_NODE_DEFINITION(identifier, variable_type);
}

/*  type
    Parses strings in the language generated by the rule:
    <type> -> float
              int
              bool
	          string
*/
AST_NODE_TYPE * type() {
    // cout << "Entered <type>" << endl;
    AST_NODE_TYPE * returner = NULL;
    if(token == FLOAT || token == BOOL || token == INTEGER || token == STRING) { // If the type is one of our valid 4 basic types, then consume 
                                                                                 // the token and load the next one.
        returner = new AST_NODE_TYPE(convertType(token));
        lex();
    }else { // If not, then throw an error for invalid type
        error("Invalid type");
    }
    // cout << "Exited <type>" << endl;
    return returner;
}

/*  statement
    Parses strings in the language generated by the rule:
    <statement> --> <assignment>
                    <ctrl_statement>
		            <io_statement>
		            <return_statement>
*/
AST_NODE_STATEMENT * statement() {
    // cout << "Entered <statement>" << endl;
    AST_NODE_STATEMENT * returner = NULL;
    if(token == SET) { // All of the following if and else if statements check if the token corresponds to a terminal symbol of any of the 4 
                       // statement types (assignment, control, input/output, or return statements). If the token does, then parse that statement
        returner = assignment();// Parse assignment non-terminal
    }else if(token == IF || token == FOR || token == WHILE) {
        returner = ctrl_statement(); // Parse control statement non-terminal
    }else if(token == INPUT || token == DISPLAY) {
        returner = io_statement(); // Parse input/output non-terminal
    }else if(token == CALL) {
        returner = new AST_NODE_STATEMENT_EXPRESSION(function_call());
    }else if(token == RETURN) {
        returner = return_statement(); // Parse retun non-terminal
    }else{
        error("Expected a statement"); // Throw an error because the statement entered was not a syntactically correct statement 
    }
    // cout << "Exited <statement>" << endl;
    return returner;
}

/*  assignment
    Parses strings in the language generated by the rule:
    <assignment> --> set <id> = <expr>
*/
AST_NODE_ASSIGNMENT * assignment() {
    // cout << "Entered <assignment>" << endl;
    if(token != SET) {
        error("Expected word set");
    }
    lex(); // Error check, consume token, load token
    AST_NODE_ID * identifier = id(); // Parse identifier
    if(token != EQ_OP) {
        error("Expected symbol =");
    }
    lex();// Error check, consume token, load token
    AST_NODE_EXPR * expression = expr(); //parse expression non-terminal
    // cout << "Exited <asignment>" << endl;
    return new AST_NODE_ASSIGNMENT(identifier, expression);
}

/*  ctrl_statement
    Parses strings in the language generated by the rule:
    <ctrl_statement> --> <if_statement> 
                         <loop>
*/ 
AST_NODE_STATEMENT * ctrl_statement() {
    // cout << "Entered <ctrl_statement>" << endl;
    AST_NODE_STATEMENT * returner = NULL;
    if(token == IF) { // Check to see if token corresponds to an if statement. If it does, parse the if statement non-terminal
        returner = if_statement();
    }else if(token == FOR || token == WHILE) { // Check to see if token corresponds to a loop. If it does, parse the loop non-terminal
        returner = loop();
    }else{ // Otherwise, throw an error for not being a control statement
        error("Expected a loop or an if statement");
    }
    // cout << "Exited <ctrl_statement>" << endl;
    return returner;
}

/*  io_statement
    Parses strings in the language generated by the rule:
    <io_statement> --> input "STRING_LIT", <id>
		               display <expr>{COMMA<expr}

*/
AST_NODE_STATEMENT * io_statement() {
    // cout << "Entered io_statement" << endl;
    AST_NODE_STRING * string_value = NULL;
    if(token == INPUT) { //if the IO statement is specifically an input statement, parse the input statement
        lex(); //consume the token coresponding to the input token and load the next token
        if(token != STRING_LIT) {
            error("Expected a string value");
        }else {
            string value(lexeme);
            string_value = new AST_NODE_STRING(value);
        }
        lex(); //Error check, consume token, load token
        if(token != COMMA) {
            error("Expected a comma");
        }
        lex(); //Error check, consume token, load token
        AST_NODE_ID * identifier = id(); //parse the indentifier non-terminal
        // cout << "Exited <io_statement>" << endl;
        return new AST_NODE_INPUT(string_value, identifier);

    }else if(token == DISPLAY) { //if the IO statement is specifically an output statement, parse the output statement
        vector<AST_NODE_EXPR *> expr_list;
        AST_NODE_EXPR * adder = NULL; 
        lex(); // Consume the token corresponding to the display token and load the next token
        adder = expr(); //parse the expression non-terminal
        expr_list.push_back(adder);
        while(token == COMMA) { //if there is a comma, then consume it, load the nex token, and parse the expression non-terminal
            lex();
            adder = expr();
            expr_list.push_back(adder);
        }
        // cout << "Exited <io_statement>" << endl;
        return new AST_NODE_DISPLAY(expr_list);

    }else { //Throw an error if the statement was not actually an IO statements
        error("Expected an IO statement");
    }
    
}

/*  function_call
    Parses strings in the language generated by the rule:
    <function_call> --> call <id>, parameters, {<expr>, }
*/
AST_NODE_FUNCTION_CALL * function_call() {
    // cout << "Entered <function_call>" << endl;
    if (token != CALL) {
        error("Expected the word call");
    }
    lex();
    AST_NODE_ID * function_name = id();
    if(token != COMMA) {
        error("Expected the word parameters");
    }
    lex();
    if(token != PARAMETERS) {
        error("Expected the word parameters");
    }
    lex();
    if(token != COMMA) {
        error("Expected the word parameters");
    }
    lex();
    vector<AST_NODE_EXPR *> parameter_list;
    AST_NODE_EXPR * adder = NULL;
    while(token == IDENT || token == FLOAT_LIT || token == INT_LIT || token == STRING_LIT || token == BOOL_LIT || token == L_PAREN || token == CALL) {
        adder = expr();
        parameter_list.push_back(adder);
        if(token != COMMA) {
            break;
        }
        lex();
    }
    return new AST_NODE_FUNCTION_CALL(function_name, parameter_list);
}

/*  return_statement
    Parses strings in the language generated by the rule:
    <return_statement> --> return <expr>
*/
AST_NODE_RETURN * return_statement() {
    // cout << "Entered <return_statement>" << endl;
    if(token != RETURN) {
        error("Expected return statement");
    }
    lex(); //Error check, consume token, load token
    AST_NODE_EXPR * return_expression = expr(); //Parse the expression non-terminal
    // cout << "Exited <return_statement>" << endl;
    return new AST_NODE_RETURN(return_expression);
}

/*  expr
    Parses strings in the language generated by the rule:
    <expr> --> <term> {(AND | OR | == | > | < | >= | <=) <term>}
*/
AST_NODE_EXPR * expr() {
    // cout << "Entered <expr>" << endl;

    AST_NODE_EXPR * left = term(); //parse the first term
    AST_NODE_EXPR * right = NULL;

    while(token == AND || token == OR || token == DEQ_OP || token == GREATER || token == LESS || token == GRETER_EQ || token == LESS_EQ) {
        //While the first term and all subsequent expressions are followed by one of the allowed logic symbols, consume the symbol and parse 
        //the next expression
        int operation = token;
        lex();
        right = term();
        
        left = new AST_NODE_BIN_OP(left, right, operation);

    }

    // cout << "Exited <expr>" << endl;
    return left;
}

/*  term
    Parses strings in the language generated by the rule:
    <term> --> <factor> {(+ | -) <factor>}
*/
AST_NODE_EXPR * term() {

    // cout << "Entered <term>" << endl;

    AST_NODE_EXPR * left = factor(); //parse the first factor
    AST_NODE_EXPR * right = NULL;

    while(token == ADD_OP || token == SUB_OP) {
        //While the first factor and all subsequent terms are followed by one of the allowed arithmetic symbols, consume the symbol and parse 
        //the next term
        int operation = token;
        lex();
        right = factor();
        left = new AST_NODE_BIN_OP(left,right,operation);
    }

    // cout << "Exited <term>" << endl;
    return left;
}

/*  factor
    Parses strings in the language generated by the rule:
    <factor> --> <primary> {(* | /) <factor>}
*/
AST_NODE_EXPR * factor() {
    // cout << "Entered <factor>" << endl;

    AST_NODE_EXPR * left = primary(); //Parse the first primary
    AST_NODE_EXPR * right = NULL;

    while(token == MULT_OP || token == DIV_OP) {
        //While the first primary and all subsequent factors are followed by one of the allowed arithmetic symbols, consume the symbol and parse 
        //the next factor
        int operation = token;
        lex();
        right = primary();
        left = new AST_NODE_BIN_OP(left, right, operation);
        }

    // cout << "Exited <factor>" << endl;
    return left;
}

/*  primary
    Parses strings in the language generated by the rule:
    <primary> --> FLOAT_LIT
	              INT_LIT
	              BOOL_LIT
	              STRING_LIT
                  ( <expr> )
                  <id>

*/
AST_NODE_EXPR * primary() {
    // cout << "Entered <primary>" << endl;

    if(token == INT_LIT) { //If the primary expression is a literal of some sort, consume it and move to the next token 
        int value = atoi(lexeme);
        lex();
        // cout << "Exited <primary>" << endl;
        return new AST_NODE_INTEGER(value);
    }else if(token == FLOAT_LIT) {//If the primary expression is a literal of some sort, consume it and move to the next token
        float value = atof(lexeme);
        lex();
        // cout << "Exited <primary>" << endl;
        return new AST_NODE_FLOAT(value);
    }else if(token == TRUE || token == FALSE) {//If the primary expression is a literal of some sort, consume it and move to the next token
        bool value = token == TRUE;
        lex();
        // cout << "Exited <primary>" << endl;
        return new AST_NODE_BOOLEAN(value);
    } else if(token == STRING_LIT) {//If the primary expression is a literal of some sort, consume it and move to the next token
        string value(lexeme);
        lex();
        // cout << "Exited <primary>" << endl;
        return new AST_NODE_STRING(value);
    
    } else if(token == L_PAREN) {
        //Else if the token is a left parentheses, consume the token, load the next one, and parse the expression non-terminal
        lex();
        AST_NODE_EXPR * expression = expr();
        if(token != R_PAREN) {
            error("Expected symbol )");
        }
        lex(); //Error check, consume, and load the token
        // cout << "Exited <primary>" << endl;
        return expression;
    } else if(token == IDENT){
        //Else if the token is an indentifier, parse the identifier
        AST_NODE_ID * identifier = id();
        // cout << "Exited <primary>" << endl;
        return new AST_NODE_VARIABLE(identifier);
    }else if(token == CALL) {
        AST_NODE_FUNCTION_CALL * function_called = function_call();
        // cout << "Exited <primary>" << endl;
        return function_called;
    }else { //Other wise, throw an error
        error("Expected a primary expression");
    }
}

/*  id
    Parses strings in the language generated by the rule:
    <id> --> IDENT
*/
AST_NODE_ID * id() {
    // cout << "Entered <id>" << endl;
    string variable_name(lexeme);
    //If the token is correct (an identifier), consume the token and load the next one. Otherwise, throw an error
    if(token == IDENT) {
        lex();
    }else {
        error("Expected an identifier");
    }

    // cout << "Exited <id>" << endl;
    return new AST_NODE_ID(variable_name);
}

/*  if_statement
    Parses strings in the language generated by the rule:
    <if_statement> --> if <expr> then <statement>* {elseif <expr> then <statement>*} [else <statement>*] endif
*/
AST_NODE_IF_STATEMENT * if_statement() {
    // cout << "Entered <if_statement>" << endl;
    AST_NODE_STATEMENT * adder = NULL;
    vector<AST_NODE_STATEMENT *> statement_list;
    vector<AST_NODE_ELSEIF *> else_if_list;
    vector<AST_NODE_STATEMENT *> else_statement_list;

    if(token != IF) {
        error("Expected word if");
    }
    lex(); //Error check, consume, and load the token
    AST_NODE_EXPR * control_exprssion = expr(); //parse the control expression
    if(token != THEN) {
        error("Expected word then");
    }
    lex(); //Error check, consume, and load the token
    while(isStatement()) { //Continusously parse statements while the token is a statement
        adder = statement();
        statement_list.push_back(adder);
    }
    while(token == ELSEIF) {//if there are any elseif statements, loop until there are no more elseif statements
        
        lex(); //consume the elseif token and load the next one
        AST_NODE_EXPR * else_if_control_expression = expr(); //parse the elseif control expression
        vector<AST_NODE_STATEMENT *> else_if_statement_list;
        if(token != THEN) {
            error("Expected word then");
        }
        lex();//Error check, consume, and load the token
        while(isStatement()) {//Continusously parse statements while the token is a statement
            adder = statement();
            else_if_statement_list.push_back(adder);
        }
        else_if_list.push_back(new AST_NODE_ELSEIF(else_if_control_expression, else_if_statement_list));
    }
    if(token == ELSE) { //Check to see if there is a else statement to parse
        lex(); //consume he else token and load the next one 
        while(isStatement()) { //Continusously parse statements while the token is a statement
            adder = statement();
            else_statement_list.push_back(adder);
        }
    }
    if (token != ENDIF) {
        error("Expected word endif");
    }
    lex();//Error check, consume, and load the token
    // cout << "Exited <if_statement>" << endl;
    return new AST_NODE_IF_STATEMENT(control_exprssion, statement_list, else_if_list, else_statement_list);
}

/*  loop
    Parses strings in the language generated by the rule:
    <loop> --> <for_loop> 
           <while_loop>

*/
AST_NODE_STATEMENT * loop() {
    // cout << "Entered <loop>" << endl;
    if(token == FOR) { //If the token matches a for loop, call the for loop's non-terminal function
        AST_NODE_FOR_LOOP * floop = for_loop();
        // cout << "Exited <loop>" << endl;
        return floop;
    }else if(token == WHILE) {//If the token matches a while loop, call the while loop's non-terminal function
        AST_NODE_WHILE_LOOP * wloop = while_loop();
        // cout << "Exited <loop>" << endl;
        return wloop;
    }else { //else print out an arror
        error("Expected a for loop or while loop");
    }
    
}


/*  for_loop
    Parses strings in the language generated by the rule:
    <for_loop> --> for <id> = <expr> to <expr> do <statement>* endfor
*/
AST_NODE_FOR_LOOP * for_loop() {
    // cout << "Entered <for_loop>" << endl;
    if(token != FOR) {
        error("Expected word for");
    }
    lex(); //Error check, consume, and load the token
    AST_NODE_ID * identifier = id(); //parse the identifier
    if(token != EQ_OP) {
        error("Expected symbol =");
    }
    lex(); //Error check, consume, and load the token
    AST_NODE_EXPR * initial_value = expr(); //parse the expression to set the loop variable's initial value
    if(token != TO) {
        error("Expected word to");
    }
    lex(); //Error check, consume, and load the token
    AST_NODE_EXPR * final_value = expr();//parse the expression to set the loop variable's final value
    if(token != DO) {
        error("Expecte word do");
    }
    lex();//Error check, consume, and load the token
    AST_NODE_STATEMENT * adder = NULL;
    vector<AST_NODE_STATEMENT *> statement_list;
    while(isStatement()) {//Continusously parse statements while the token is a statement
        adder = statement();
        statement_list.push_back(adder);
    }
    if(token != ENDFOR) {
        error("Expected word endfor");
    }
    lex();  //Error check, consume, and load the token
    
    // cout << "Exited <for_loop>" << endl;
    return new AST_NODE_FOR_LOOP(identifier, initial_value, final_value, statement_list);
}


/*  while_loop
    Parses strings in the language generated by the rule:
    <while_loop> --> while <expr> do <statement>* endwhile
*/
AST_NODE_WHILE_LOOP * while_loop() {
    // cout << "Entered <while_loop>" << endl;
    if(token != WHILE) {
        error("Expected word while");
    }
    lex(); //Error check, consume, and load the token
    AST_NODE_EXPR * control_expression = expr(); //parse the expression of the loop's control statement
    if(token != DO) {
        error("Expected word do");
    }
    lex();//Error check, consume, and load the token
    AST_NODE_STATEMENT * adder = NULL;
    vector<AST_NODE_STATEMENT *> statement_list;
    while(isStatement()) { //Continusously parse statements while the token is a statement
        adder = statement();
        statement_list.push_back(adder);
    }
    if(token != ENDWHILE) {
        error("Expected word endwhile");
    }
    lex(); //Error check, consume, and load the token
        
    // cout << "Exited <while_loop>" << endl;
    return new AST_NODE_WHILE_LOOP(control_expression, statement_list);
}



//This function is called within the parser when a token does not match the correct syntax described by our grammar. 
void error(string message) {
    cerr << "Error: " << message << endl;
    exit(1);
}

//This is a simple helper function to check to see if the token corresponds with any of the terminal symbols that 
//could start any kind of statement (assignment, control, IO, or return statements)
bool isStatement() {
    return (token == SET || token == IF || token == FOR || token == WHILE || token == INPUT || token == DISPLAY || token == RETURN);
}

int convertType(int parsedType) {
    if(parsedType == INTEGER) {
        return TYPE_INTEGER;
    }else if(parsedType == FLOAT) {
        return TYPE_FLOAT;
    }else if(parsedType == BOOL) {
        return TYPE_BOOLEAN;
    }else if(parsedType == STRING) {
        return TYPE_STRING;
    }else {
        return TYPE_VOID;
    }

}

void determineOutput(SCL_TYPE output) {
    if(output.actualType == TYPE_INTEGER) {
        cout << "Output from program was: " << output.intValue << endl;
    }else if(output.actualType == TYPE_FLOAT) {
        cout << "Output from program was: " << output.floatValue << endl;
    }else if(output.actualType == TYPE_BOOLEAN) {
        cout << "Output from program was: " << output.boolValue << endl;
    }else if(output.actualType == TYPE_STRING) {
        cout << "Output from program was: " << output.stringValue << endl;
    }else if (output.actualType == TYPE_VOID) {
        cout << "This program has a void output" << endl;
    }else {
        SCLError("Reached end of program with no return");
    }
}
